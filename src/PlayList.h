//////////////////////////////////////////////////////////////////////////////
//
//  PlayList.h
//
//  CFileInfo, CFileList, and CPlayList classes.
//
//----------------------------------------------------------------------------
//
//  Copyright 2020 by State University of Catatonia and other Contributors
//
//  This file is provided under a "BSD 3-Clause" open source license.
//  The full text of the license is provided in the "LICENSE.txt" file.
//
//  SPDX-License-Identifier: BSD-3-Clause
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "Options.h"

//////////////////////////////////////////////////////////////////////////////
//
//  CFileInfo
//
//////////////////////////////////////////////////////////////////////////////

// File information.
class CFileInfo
{
    public:

        // No default ctor.
        CFileInfo() = delete;

        // No copy ctor.
        CFileInfo(const CFileInfo&) = delete;

        // No copy assignment.
        CFileInfo& operator=(const CFileInfo&) = delete;

    public:

        // Construct CFileInfo object from fs::path.
        CFileInfo(const fs::path& path)
            :
            m_FullPath(path),
            m_DisplayName(path.stem())
        {
        }

        // Move ctor.
        CFileInfo(CFileInfo&& that) noexcept
            :
            m_FullPath(),
            m_DisplayName()
        {
            swap(that);
        }

        // Move assignment.
        CFileInfo& operator=(CFileInfo&& that) noexcept
        {
            if (this != &that)
            {
                m_FullPath.clear();
                m_DisplayName.clear();
                swap(that);
            }
            return *this;
        }

        // Swap CFileInfo objects.
        void swap(CFileInfo& that) noexcept
        {
            if (this != &that)
            {
                std::swap(this->m_FullPath,    that.m_FullPath);
                std::swap(this->m_DisplayName, that.m_DisplayName);
            }
        }

        // Get display name for the file.
        LPCWSTR GetDisplayName()
        {
            // There is a CPU vs memory tradeoff with the display name.
            // The name was originally generated by GetDisplayName()
            // on every call, which saved memory and was performant
            // for purposes of displaying the names in the listview.
            // But then I tried to sort the playlist by display name,
            // and it was 100X slower than sorting by full path.
            // So now the display name is generated by the ctor,
            // and saved with the CFileInfo object.

            return m_DisplayName.c_str();
        }

        // Get large (256x256) thumbnail bitmap for file using IShellItemImageFactory.
        HBITMAP GetLargeThumbnail() const;

    public:

        fs::path m_FullPath;
        std::wstring m_DisplayName;
};

//////////////////////////////////////////////////////////////////////////////
//
//  CFileList
//
//////////////////////////////////////////////////////////////////////////////

// File list (in memory).
class CFileList
{
    protected:

        using ContainerType = std::vector<CFileInfo*>;

        ContainerType m_Files;

    public:

        // Make the CFileList class act like m_Files container.

        using value_type        = ContainerType::value_type;
        using reference         = ContainerType::reference;
        using const_reference   = ContainerType::const_reference;
        using pointer           = ContainerType::pointer;
        using const_pointer     = ContainerType::const_pointer;
        using iterator          = ContainerType::iterator;
        using const_iterator    = ContainerType::const_iterator;
        using size_type         = ContainerType::size_type;

        FORCEINLINE iterator begin() noexcept               { return m_Files.begin();     }
        FORCEINLINE iterator end() noexcept                 { return m_Files.end();       }
        FORCEINLINE const_iterator cbegin() const noexcept  { return m_Files.cbegin();    }
        FORCEINLINE const_iterator cend() const noexcept    { return m_Files.cend();      }
        FORCEINLINE reference front()                       { return m_Files.front();     }
        FORCEINLINE const_reference front() const           { return m_Files.front();     }
        FORCEINLINE reference back()                        { return m_Files.back();      }
        FORCEINLINE const_reference back() const            { return m_Files.back();      }
        FORCEINLINE iterator iat(size_type idx) noexcept    { return m_Files.begin()+idx; }
        FORCEINLINE size_type size() const noexcept         { return m_Files.size();      }
        FORCEINLINE bool empty() const noexcept             { return m_Files.empty();     }
        FORCEINLINE void reserve(size_type capacity)        { m_Files.reserve(capacity);  }
        void clear() noexcept;

    public:

        CFileList()
            :
            m_Files()
        {
        }

        ~CFileList()
        {
            clear();
        }

        // No copy ctor.
        CFileList(const CFileList&) = delete;

        // No copy assignment.
        CFileList& operator=(const CFileList&) = delete;

        // Move ctor.
        CFileList(CFileList&& that) noexcept
            :
            m_Files(std::move(that.m_Files))
        {
        }

        // Move assignment.
        CFileList&
        operator=(
            CFileList&& that
        )
        noexcept
        {
            if (this != &that)
            {
                clear();
                this->m_Files = std::move(that.m_Files);
            }
            return *this;
        }

        // Find file in list (by path).
        CFileList::iterator
        Find(
            const fs::path& path
        );

        // Find file in list (by CFileInfo pointer).
        iterator
        Find(
            const CFileInfo* pFile
        );

        // Add single file or entire directory to file list.
        // Prevents duplicate files from being added to list.
        // Returns iterator to first added file, or end() if error.
        iterator
        Add(
            const fs::path& path,           // File or directory to add.
            bool recurseIntoSubdirs = false // Recurse into subdirectories?
        );

        // Remove an entry from the file list (by path).
        bool
        Remove(
            const fs::path& path    // Full path of file to remove.
        )
        {
            iterator it = Find(path);
            return (it != end()) ? Remove(it) : false;
        }

        // Remove an entry from the file list (by CFileInfo pointer).
        bool
        Remove(
            CFileInfo* pFile         // CFileInfo of file to remove.
        )
        {
            iterator it = Find(pFile);
            return (it != end()) ? Remove(it) : false;
        }

        // Remove an entry from the file list (by iterator).
        bool
        Remove(
            iterator it
        );

        // Sort the file list.
        void
        Sort();

        // Randomly shuffle the file list.
        void
        Shuffle();

        // Pick a random file from the list.
        CFileInfo*
        GetRandom();

    private:

        // Add file to m_Files if it doesn't already exist.
        // Returns iterator to added file, or end() if already exists.
        iterator
        AddIfNew(
            const fs::path& path
        );
};

//////////////////////////////////////////////////////////////////////////////
//
//  CPlayList
//
//////////////////////////////////////////////////////////////////////////////

// Play list (CFileList that can be persisted to disk).
class CPlayList : public CFileList
{
    public:

        // Construct playlist object.
        CPlayList()
            :
            CFileList(),
            m_PlaylistPath()
        {
        }

        // Destroy playlist object.
        ~CPlayList()
        {
        }

        // No copy ctor.
        CPlayList(const CPlayList&) = delete;

        // No copy assignment.
        CPlayList& operator=(const CPlayList&) = delete;

        // Move ctor.
        CPlayList(CPlayList&& that) noexcept
            :
            CFileList(std::move(that)),
            m_PlaylistPath(std::move(that.m_PlaylistPath))
        {
        }

        // Move assignment.
        CPlayList&
        operator=(
            CPlayList&& that
        )
        noexcept
        {
            if (this != &that)
            {
                CFileList::operator=(std::move(that));
                this->m_PlaylistPath = std::move(that.m_PlaylistPath);
            }
            return *this;
        }

    public:

        // Load playlist.
        bool
        Load(
            const fs::path& path
        );

        // Save playlist.
        bool
        Save()
        {
            return Save(m_PlaylistPath);
        }

        // Save playlist.
        bool
        Save(
            const fs::path& path
        );

        // Get the name of this playlist.
        std::wstring
        GetPlaylistName()
        {
            return m_PlaylistPath.stem();
        }

        // Change playlist name.
        void
        SetPlaylistName(
            ConstWString newName
        )
        {
            m_PlaylistPath = NameToPath(newName);
        }

        // Clear playlist.
        void
        clear()
        {
            CFileList::clear();
            m_PlaylistPath.clear();
        }

        // Get playlist file path.
        static
        fs::path
        NameToPath(
            ConstWString playlistName
        );

        // Get names of all the playlists.
        static
        std::vector<std::wstring>
        GetAllPlaylists();

        // Create the default playlist files, if needed.
        static
        void
        CreateDefaultPlaylists();

    private:

        fs::path m_PlaylistPath;
};
